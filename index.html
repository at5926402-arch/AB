<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Angry Stick: Zombies</title>
<style>
  html,body { height:100%; margin:0; background:#0b0b0f; font-family:Segoe UI,Roboto,sans-serif; color:#eee; }
  #gameWrap { display:flex; height:100vh; align-items:center; justify-content:center; }
  canvas { background: linear-gradient(#111, #0b0b0f); border:4px solid #222; border-radius:8px; box-shadow: 0 10px 30px rgba(0,0,0,0.7); }
  #hud { position: absolute; top:12px; left:12px; color:#fff; font-weight:600; }
  #hud .small { font-size:13px; opacity:.85; }
  #overlay { position: absolute; text-align:center; color:#fff; pointer-events:none; }
  button { padding:.6rem 1rem; margin-top:10px; border-radius:6px; border:none; cursor:pointer; background:#ff3b3b; color:#fff; font-weight:700;}
  .muted { opacity:.6 }
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="c" width="960" height="600"></canvas>
  <div id="hud">
    <div id="score">Score: 0</div>
    <div class="small" id="wave">Wave: 1</div>
    <div class="small" id="health">Health: 100</div>
    <div class="small" id="info">Click to shoot • WASD to move • P pause • M mute</div>
  </div>
  <div id="overlay" style="width:960px;height:600px;display:flex;flex-direction:column;align-items:center;justify-content:center;">
    <!-- overlay content injected by JS -->
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const scoreEl = document.getElementById('score');
  const waveEl = document.getElementById('wave');
  const healthEl = document.getElementById('health');

  const W = canvas.width, H = canvas.height;
  let last = 0;
  let keys = {};
  let mouse = {x: W/2, y: H/2, down:false};
  let bullets = [];
  let zombies = [];
  let particles = [];
  let score = 0;
  let wave = 1;
  let player;
  let paused = false;
  let muted = false;
  let gameOver = false;

  function rand(a,b){return a + Math.random()*(b-a);}
  function dist(a,b){return Math.hypot(a.x-b.x, a.y-b.y);}

  // simple audio helper (beeps)
  function beep(freq, duration=0.08, vol=0.2){
    if(muted) return;
    try {
      const ctxAudio = (window._audioCtx ||= new (window.AudioContext||window.webkitAudioContext)());
      const o = ctxAudio.createOscillator();
      const g = ctxAudio.createGain();
      o.type = 'square';
      o.frequency.value = freq;
      g.gain.value = vol;
      o.connect(g); g.connect(ctxAudio.destination);
      o.start();
      setTimeout(()=>{ o.stop(); }, duration*1000);
    } catch(e){}
  }

  // Player
  function createPlayer(){
    player = {
      x: W/2, y: H/2,
      r: 12,
      speed: 250,
      health: 100,
      cooldown: 0
    };
  }

  // Bullet
  function fireBullet(targetX, targetY){
    if(player.cooldown > 0) return;
    const angle = Math.atan2(targetY - player.y, targetX - player.x);
    const speed = 700;
    bullets.push({
      x: player.x + Math.cos(angle)*(player.r+8),
      y: player.y + Math.sin(angle)*(player.r+8),
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed,
      r: 4,
      life: 1.2
    });
    player.cooldown = 0.18;
    beep(1200,0.06,0.12);
  }

  // Zombie
  function spawnZombie(){
    // spawn at random edge
    const side = Math.floor(Math.random()*4);
    let x,y;
    if(side===0){ x = rand(-60,-20); y = rand(-20,H+20); }
    else if(side===1){ x = rand(W+20,W+60); y = rand(-20,H+20); }
    else if(side===2){ x = rand(-20,W+20); y = rand(-60,-20); }
    else { x = rand(-20,W+20); y = rand(H+20,H+60); }
    const spd = rand(35 + wave*8, 70 + wave*10);
    const hp = Math.floor(10 + wave*6 + Math.random()*10);
    zombies.push({x,y,vx:0,vy:0,r:18,hp,maxHp:hp,spd});
  }

  // Particles
  function spawnParticles(x,y,color,count=12){
    for(let i=0;i<count;i++){
      const a = rand(0,Math.PI*2);
      const s = rand(60,260);
      particles.push({
        x,y,vx:Math.cos(a)*s, vy:Math.sin(a)*s, life: rand(0.4,0.9),
        r: rand(1.5,4), col: color
      });
    }
  }

  // Game init / wave control
  function startWave(n){
    for(let i=0;i<n;i++){
      setTimeout(spawnZombie, i*350);
    }
  }

  function nextWave(){
    wave++;
    waveEl.innerText = 'Wave: ' + wave;
    startWave(4 + wave*3);
  }

  function resetGame(){
    score = 0;
    wave = 1;
    zombies.length = 0;
    bullets.length = 0;
    particles.length = 0;
    createPlayer();
    scoreEl.innerText = 'Score: 0';
    waveEl.innerText = 'Wave: 1';
    healthEl.innerText = 'Health: ' + player.health;
    gameOver = false;
    overlay.innerHTML = '';
    startWave(6);
  }

  // Input
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if(e.key.toLowerCase() === 'p'){ paused = !paused; showPause(); }
    if(e.key.toLowerCase() === 'm'){ muted = !muted; document.body.classList.toggle('muted', muted); }
    if(e.key === ' '){ // space to shoot toward mouse
      fireBullet(mouse.x, mouse.y);
    }
  });
  window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
  });
  canvas.addEventListener('mousedown', e => { mouse.down = true; fireBullet(mouse.x, mouse.y); });
  window.addEventListener('mouseup', e => { mouse.down = false; });

  // Pause display
  function showPause(){
    overlay.innerHTML = paused ? `<div style="background:rgba(0,0,0,0.6);padding:20px;border-radius:8px;"><h1>PAUSED</h1><div class="small">Press P to resume</div></div>` : '';
  }

  // Main loop
  function update(dt){
    if(paused || gameOver) return;
    // player movement
    let dx = 0, dy = 0;
    if(keys['w'] || keys['arrowup']) dy -= 1;
    if(keys['s'] || keys['arrowdown']) dy += 1;
    if(keys['a'] || keys['arrowleft']) dx -= 1;
    if(keys['d'] || keys['arrowright']) dx += 1;
    if(dx || dy){
      const len = Math.hypot(dx,dy);
      dx/=len; dy/=len;
      player.x += dx * player.speed * dt;
      player.y += dy * player.speed * dt;
      // clamp
      player.x = Math.max(20, Math.min(W-20, player.x));
      player.y = Math.max(20, Math.min(H-20, player.y));
    }

    // cooldown
    if(player.cooldown>0) player.cooldown = Math.max(0, player.cooldown - dt);

    // auto-fire if mouse held
    if(mouse.down) fireBullet(mouse.x, mouse.y);

    // bullets update
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;
      if(b.life <= 0 || b.x < -20 || b.x > W+20 || b.y < -20 || b.y > H+20){
        bullets.splice(i,1);
      }
    }

    // zombies update
    for(let i=zombies.length-1;i>=0;i--){
      const z = zombies[i];
      // move toward player
      const ang = Math.atan2(player.y - z.y, player.x - z.x);
      z.vx = Math.cos(ang)*z.spd;
      z.vy = Math.sin(ang)*z.spd;
      z.x += z.vx * dt;
      z.y += z.vy * dt;

      // collision with bullets
      for(let j=bullets.length-1;j>=0;j--){
        const b = bullets[j];
        const d = Math.hypot(b.x - z.x, b.y - z.y);
        if(d < z.r + b.r){
          // hit
          z.hp -= 10 + Math.floor(Math.random()*8);
          // particles
          spawnParticles(b.x, b.y, '#ffcc00', 8);
          bullets.splice(j,1);
          beep(900,0.04,0.08);
          if(z.hp <= 0){
            spawnParticles(z.x, z.y, '#8be04b', 18 + Math.floor(Math.random()*8));
            zombies.splice(i,1);
            score += 10;
            scoreEl.innerText = 'Score: ' + score;
            // small chance to drop health
            if(Math.random() < 0.08){
              player.health = Math.min(100, player.health + 8);
              beep(1600,0.06,0.08);
            }
            break;
          }
        }
      }

      // collision with player
      const d2 = Math.hypot(player.x - z.x, player.y - z.y);
      if(d2 < z.r + player.r + 2){
        // bite
        player.health -= Math.floor(8 + Math.random()*12) * dt * 4;
        // push zombie slightly back
        const push = 6;
        z.x -= Math.cos(ang)*push;
        z.y -= Math.sin(ang)*push;
        // damage particles
        spawnParticles(player.x + Math.cos(ang)*10, player.y + Math.sin(ang)*10, '#ff4d4d', 4);
        if(player.health <= 0){
          player.health = 0;
          die();
        }
        healthEl.innerText = 'Health: ' + Math.max(0, Math.floor(player.health));
      }
    }

    // particles
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.vx *= 0.98;
      p.vy *= 0.98;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      if(p.life <= 0) particles.splice(i,1);
    }

    // if all zombies dead, next wave after small delay
    if(zombies.length === 0 && !gameOver){
      setTimeout(nextWave, 800);
    }

    // spawn rate increases slightly with wave if none left
    if(zombies.length < Math.min(2, wave) && Math.random() < 0.01 + wave*0.003){
      spawnZombie();
    }
  }

  // draw stickman
  function drawPlayer(){
    // body
    ctx.lineWidth = 6;
    ctx.strokeStyle = '#eaeaea';
    ctx.beginPath();
    ctx.moveTo(player.x, player.y - 6);
    ctx.lineTo(player.x, player.y + 18);
    ctx.stroke();
    // head
    ctx.beginPath();
    ctx.fillStyle = '#eaeaea';
    ctx.arc(player.x, player.y - 18, 10, 0, Math.PI*2);
    ctx.fill();
    // arms aiming toward mouse
    const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    ctx.strokeStyle = '#ff4d4d';
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.moveTo(player.x, player.y - 4);
    ctx.lineTo(player.x + Math.cos(ang)*28, player.y + Math.sin(ang)*28);
    ctx.stroke();

    // gun barrel
    ctx.fillStyle = '#222';
    ctx.fillRect(player.x + Math.cos(ang)*28 - 6, player.y + Math.sin(ang)*28 - 4, 14, 8);
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    // ground grid
    ctx.save();
    ctx.globalAlpha = 0.03;
    ctx.strokeStyle = '#fff';
    for(let gx=0;gx<W;gx+=40){
      ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,H); ctx.stroke();
    }
    for(let gy=0;gy<H;gy+=40){
      ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(W,gy); ctx.stroke();
    }
    ctx.restore();

    // draw zombies
    for(const z of zombies){
      // body
      const healthPct = z.hp / z.maxHp;
      ctx.save();
      ctx.translate(z.x,z.y);
      ctx.rotate(Math.atan2(player.y - z.y, player.x - z.x) + Math.PI/2);
      // shadow
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.ellipse(0+2, z.r+8, z.r+8, 6, 0,0,Math.PI*2);
      ctx.fill();
      // zombie body (green)
      ctx.fillStyle = '#4b8d3b';
      ctx.beginPath();
      ctx.ellipse(0,0, z.r, z.r*1.2, 0,0,Math.PI*2);
      ctx.fill();
      // eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(-6,-6,3,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(6,-6,3,0,Math.PI*2); ctx.fill();
      // pupil
      ctx.fillStyle='#222'; ctx.beginPath(); ctx.arc(-6,-6,1.3,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(6,-6,1.3,0,Math.PI*2); ctx.fill();
      // mouth
      ctx.strokeStyle='#222'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(-6,4); ctx.lineTo(6,4); ctx.stroke();
      // hp bar
      ctx.fillStyle = '#222';
      ctx.fillRect(-z.r, -z.r-12, z.r*2, 6);
      ctx.fillStyle = '#ff4d4d';
      ctx.fillRect(-z.r+1, -z.r-11, (z.r*2-2)*(1-healthPct), 4);
      ctx.fillStyle = '#7fff7f';
      ctx.fillRect(-z.r+1 + (z.r*2-2)*(1-healthPct), -z.r-11, (z.r*2-2)*healthPct, 4);
      ctx.restore();
    }

    // draw bullets
    for(const b of bullets){
      ctx.beginPath();
      ctx.fillStyle = '#ffd800';
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }

    // particles
    for(const p of particles){
      ctx.beginPath();
      ctx.fillStyle = p.col;
      ctx.globalAlpha = Math.max(0, p.life / 1.1);
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // draw player on top
    drawPlayer();

    // HUD text handled separately
    if(paused){
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff'; ctx.font = '36px system-ui'; ctx.textAlign='center';
      ctx.fillText('PAUSED', W/2, H/2 - 10);
    }
  }

  function die(){
    gameOver = true;
    beep(200,0.2,0.4);
    overlay.innerHTML = `
      <div style="background:rgba(0,0,0,0.7);padding:26px;border-radius:10px;">
        <h1 style="margin:0 0 6px 0;font-size:34px;">GAME OVER</h1>
        <div style="margin-bottom:12px;color:#ccc">Score: <strong>${score}</strong> • Wave: ${wave}</div>
        <div><button id="restart">Restart</button></div>
      </div>`;
    document.getElementById('restart').addEventListener('click', ()=>{ resetGame(); });
  }

  // main animation frame
  function loop(t){
    const now = t/1000;
    const dt = Math.min(0.05, now - (last || now));
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // start
  createPlayer();
  resetGame();
  // initial spawn
  startWave(6);
  requestAnimationFrame(loop);

  // small help: make canvas responsive (scale to window while keeping ratio)
  function fitCanvas(){
    const wrap = document.getElementById('gameWrap');
    const wRatio = window.innerWidth / W;
    const hRatio = window.innerHeight / H;
    const scale = Math.min(wRatio*0.95, hRatio*0.95, 1);
    canvas.style.transform = `scale(${scale})`;
    canvas.style.transformOrigin = 'center';
    overlay.style.transform = canvas.style.transform;
    overlay.style.width = canvas.width + 'px';
    overlay.style.height = canvas.height + 'px';
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

})();
</script>
</body>
</html>
